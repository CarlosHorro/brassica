.container.docs
  %h2.page-title Brassica Information Portal API

  .row
    .col-sm-2
      %nav.docs-sidebar
        %ul.nav
          %li= link_to "General introduction", "#general-introduction"
          %li= link_to "Fetching data", "#fetching-data"
          %li= link_to "Filtering data", "#filtering-data"
          %li= link_to "Searching for data", "#searching-for-data"
          %li= link_to "Submitting data", "#submitting-data"

          - Api.models.each do |model|
            %li= link_to model.name, "##{model.name.underscore.dasherize}"

    .col-sm-10
      %h3#general-introduction.section-heading General introduction

      %p
        BIP provides HTTP REST-style API which uses JSON to represent returned
        resources. Full access to the API is allowed for all registered users.
        In order to authenticate users pass <code>X-BIP-Api-Key</code> header in
        each call to the API.

      %p
        - if user_signed_in?
          Your personal API key is available in the
          = link_to 'profile page', api_keys_path
        - else
          .alert.alert-info You need to sign in to obtain your personal API key.

      %p
        The API exposes several resources for which fetching and submission of
        new entries is supported. These include:

      %ul
        - Api.writable_models.each do |model|
          %li= model.name

      %p
        All attributes are expressed as basic data types such as <code>int</code>,
        <code>string</code>, <code>date</code> or arrays of these. Most of the related
        objects are not included in the response as a whole but as an identifier (or an array
        of identifiers), for instance <code>taxonomy_term_id</code> or <code>qtls_ids</code>.
        Use these identifiers to retrieve relevant resources with subsequent API calls.

      %p
        Related objects that are not available through dedicated API read call are, however,
        included completely inside the parent data structure, like, for example, <code>population_type</code>.
        Those are usually denoted with <code>object</code> format in the attribute tables.

      %h4 Example
      %pre.response
        %code= t('api.general.create.examples.ok_response')

      %p Several resources allow for fetching data only:

      %ul
        - Api.readonly_models.each do |model|
          %li= model.name


      %h3#fetching-data.section-heading Fetching data

      %p
        Each single resource can be fetched by giving its <code>id</code>.
        Multiple resources can be fetched with or without additional parameters
        limiting returned results. These parameters are specific for each
        resource and will be described in detail later.

      %p Fetching multiple resources always yields paginated results.

      = api_props('Pagination parameters', 'pagination.params',
          default_per_page: Kaminari.config.default_per_page,
          max_per_page: Kaminari.config.max_per_page)

      = api_props('Paginated response metadata', 'pagination.meta')

      %h4 Example
      %pre
        %code= t('api.pagination.request')

      %pre.response
        %code= t('api.pagination.response')

      %p
        <strong>Remember</strong>, you should replace the <code>X-BIP-Api-Key</code> value
        with your own API Key.


      %h3#filtering-data.section-heading Filtering data

      %p
        Most of resources might be filtered by values of specific resource attributes.
        Attribute tables, presented below per each resource type, indicate when a specific
        attribute may be a subject to filtering (look for the <strong>`Q`</strong> marker).
        The usage pattern is as follows:

      = api_props('Query filtering', 'filtering.params')

      %h4 Examples
      %ol
        %li
          %p Plant Lines filtering by <code>plant_line_name</code>
          %pre
            %code= t('api.filtering.request')

          = render partial: 'application/api/try_it', locals: { url: "/api/v1/plant_lines?plant_line[query][plant_line_name]=WINFRED" }

        %li
          %p
            Applying multiple attributes in a single query is possible as well - here we filter
            Plant Varieties by <code>owner</code> and <code>registration_year</code>
          %pre
            %code= t('api.filtering.multi_request')

          = render partial: 'application/api/try_it', locals: { url: "/api/v1/plant_varieties?plant_variety[query][owner]=Limagrain&plant_variety[query][reqistration_year]=1998" }


      %h3#searching-for-data.section-heading Searching for data

      %p
        It is also possible to search a given resource by passing a term and matching it against
        most of the attributes at once. It resembles the search capability available in BIP front page,
        but it is accessible via API. One also needs to scope the search to a chosen resource.

      %p
        <i>What exactly is being searched?</i> The resource attributes that are checked for the presence of term
        are basically all those marked with the <strong>`Q`</strong> marker in the attribute tables.
        Also, some related resource attributes are checked - the rule of thumb is that if an attribute
        value is visible as a column in the

        = link_to 'browse data', browse_data_path

        tables, it should be searchable via the <code>fetch</code> API parameter.

      = api_props('Searching', 'searching.params')

      %h4 Examples
      %ol
        %li
          %p Plant Lines search
          %pre
            %code= t('api.searching.request')

          = render partial: 'application/api/try_it', locals: { url: "/api/v1/plant_lines?plant_line[fetch]=WINFRED" }

        %li
          %p
            Please note the result metadata tells how much records in total were found - the
            <code>total_count</code> value in the <code>meta</code> result document element.
            Therefore, one is able to combine searching and pagination in a single request,
            to retrieve further data.
          %pre
            %code= t('api.searching.pagination_request')

          = render partial: 'application/api/try_it', locals: { url: "/api/v1/plant_lines?plant_line[fetch]=WINFRED&per_page=2&page=2" }

        %li
          %p
            Searching by related object attribute - the <code>name</code> of a Taxonomy Term
          %pre
            %code= t('api.searching.subobject_request')

          = render partial: 'application/api/try_it', locals: { url: "/api/v1/plant_populations?plant_population[fetch]=oleracea&per_page=5" }

      %p
        In order to maintain consistency between subsequent searches, all search results are ordered
        by internal <code>id</code> BIP identifier. This ensures the API will return the same results
        in the same order in two subsequent calls - provided, of course, new data were not submitted
        in the meantime. For this reason what one gets via `fetch` API calls might differ slightly from
        what could be seen when using the front page search form.


      %h3#submitting-data.section-heading Submitting new data

      %p
        Currently one is able to submit the following resources via API:

      %ul
        - Api.writable_models.each do |model|
          %li= model.name

      %p
        Data submission is based on JSON format. That is, the API <code>POST</code>
        request should pass a JSON document in its post data, where the most important
        element is called as the resource itself (e.g. <code>plant_population</code>).
        Each resource section below show an example of such a <code>POST</code> API call.

      %p
        For each resource there are attributes (described later) required
        for create requests. Skipping any of those will result in an
        <code>422</code> error response. Passing attributes which are not recognized by the API will also
        result in <code>422</code> error response.

      %h4 Examples
      %ol
        %li
          %p Missing value for required attribute
          %pre.response
            %code= t('api.general.create.examples.missing_required_attrs_response')

        %li
          %p Misspelled attribute name
          %pre.response
            %code= t('api.general.create.examples.unknown_attrs_response')

      %p
        Most of the resource attributes, as shown in the following attribute tables,
        are text (<code>string</code> format) - these are simply pieces of text of
        arbitrary length, enclosed in double quote marks <code>"</code>. Attributes
        that are of <code>int</code> format are passed without quotes.

      %p
        Dates should be delivered in textual format - several different notations are
        acceptable and will be recognized, but we advise to stick to a single, consistent
        format of <code>YYYY-MM-DD</code>. Examples are given below:

      %h4 Example
      %pre.response
        %code= t('api.general.create.examples.attribute_value_samples')

      %p
        Two attributes are never set by submitting users, but are rather automatically
        set by the server:

      = api_props('Default attribute values', 'general.create.default_attribute_values')

      %p
        Finally, one does not set attributes marked as <code>readonly</code> in the attribute
        tables (one such example is attribute <code>population_type</code> of Plant Population).
        Instead, one should assign a BIP identifier of such a related object when submitting
        new data. For instance, when submitting a new Plant Population:

      %h4 Example
      %pre.response
        %code= t('api.general.create.examples.wrong_vs_right_related_object')


      -# Models section follows

      - Api.models.each do |model|
        .section
          %h3.section-heading{id: model.name.underscore.dasherize}= model.name

          .description The following table explains the list of attributes describing this resource

          = api_props('Attributes', "#{model.name.underscore}.attrs")

          -# GET index
          = render partial: 'application/api/index', locals: { model: model }
          %hr

          -# GET show
          = render partial: 'application/api/show', locals: { model: model }
          %hr

          -# POST create
          - if Api.writable_model?(model)
            = render partial: 'application/api/create', locals: { model: model }
            %hr
